<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Here are some examples for the `flexi_logger` initialization."><meta name="keywords" content="rust, rustlang, rust-lang, code_examples"><title>flexi_logger::code_examples - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../flexi_logger/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../flexi_logger/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Module code_examples</a></h2><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../flexi_logger/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1">
                                <a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Module <a href="../index.html">flexi_logger</a>::<wbr><a class="mod" href="#">code_examples</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/flexi_logger/code_examples.rs.html#1-496">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Here are some examples for the <code>flexi_logger</code> initialization.</p>
<h3 id="contents"><a href="#contents">Contents</a></h3>
<ul>
<li><a href="#start-minimally-initialize-and-write-logs-to-stderr">Start minimally: Initialize, and write logs to stderr</a></li>
<li><a href="#choose-the-log-output-channel">Choose the log output channel</a></li>
<li><a href="#choose-the-write-mode">Choose the write mode</a></li>
<li><a href="#influence-the-location-and-name-of-the-log-file">Influence the location and name of the log file</a></li>
<li><a href="#specify-the-format-for-the-log-lines-explicitly">Specify the format for the log lines explicitly</a></li>
<li><a href="#use-a-fixed-log-file-and-truncate-or-append-the-file-on-each-program-start">Use a fixed log file, and truncate or append the file on each program start</a></li>
<li><a href="#rotate-the-log-file">Rotate the log file</a></li>
<li><a href="#reconfigure-the-log-specification-programmatically">Reconfigure the log specification programmatically</a></li>
<li><a href="#reconfigure-the-log-specification-dynamically-by-editing-a-spec-file">Reconfigure the log specification dynamically by editing a spec-file</a></li>
<li><a href="#reconfigure-the-file-log-writer">Reconfigure the file log writer</a></li>
<li><a href="#external-file-rotators">External file rotators</a></li>
<li><a href="#miscellaneous">Miscellaneous</a></li>
</ul>
<h3 id="start-minimally-initialize-and-write-logs-to-stderr"><a href="#start-minimally-initialize-and-write-logs-to-stderr">Start minimally: Initialize, and write logs to stderr</a></h3>
<p>Initialize by choosing one of three options to specify which log output you want to see,
and call <code>start()</code> immediately:</p>
<ul>
<li>
<p>Use <a href="../struct.Logger.html#method.try_with_env"><code>Logger::try_with_env</code></a> to
provide the log specification in the environment variable <code>RUST_LOG</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">Logger::try_with_env</span>()<span class="question-mark">?</span>.<span class="ident">start</span>()<span class="question-mark">?</span>;</code></pre></div>
</li>
<li>
<p>Use <a href="../struct.Logger.html#method.try_with_str"><code>Logger::try_with_str</code></a> to
provide the log specification programmatically:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">Logger::try_with_str</span>(<span class="string">&quot;info&quot;</span>)<span class="question-mark">?</span>.<span class="ident">start</span>()<span class="question-mark">?</span>;</code></pre></div>
</li>
<li>
<p>or use <a href="../struct.Logger.html#method.try_with_env_or_str"><code>Logger::try_with_env_or_str</code></a> to
combine both options:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">Logger::try_with_env_or_str</span>(<span class="string">&quot;info&quot;</span>)<span class="question-mark">?</span>.<span class="ident">start</span>()<span class="question-mark">?</span>;</code></pre></div>
</li>
</ul>
<p>After that, you just use the log-macros from the log crate. Those log lines that match the
log specification are then written to the default output channel (stderr).</p>
<h3 id="choose-the-log-output-channel"><a href="#choose-the-log-output-channel">Choose the log output channel</a></h3>
<p>By default, logs are written to <code>stderr</code>.
With one of
<a href="../struct.Logger.html#method.log_to_stdout"><code>Logger::log_to_stdout</code></a>,
<a href="../struct.Logger.html#method.log_to_file"><code>Logger::log_to_file</code></a>,
<a href="../struct.Logger.html#method.log_to_writer"><code>Logger::log_to_writer</code></a>,
<a href="../struct.Logger.html#method.log_to_file_and_writer"><code>Logger::log_to_file_and_writer</code></a>,
or <a href="../struct.Logger.html#method.do_not_log"><code>Logger::do_not_log</code></a>,
you can send the logs to other destinations, or write them not at all.</p>
<p>When writing to files or to a writer,
you sometimes want to see some parts of the log additionally on the terminal;
this can be achieved with
<a href="../struct.Logger.html#method.duplicate_to_stderr"><code>Logger::duplicate_to_stderr</code></a> or
<a href="../struct.Logger.html#method.duplicate_to_stdout"><code>Logger::duplicate_to_stdout</code></a>,
which duplicate log messages to the terminal.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">Logger::try_with_str</span>(<span class="string">&quot;info&quot;</span>)<span class="question-mark">?</span>
    .<span class="ident">log_to_file</span>(<span class="ident">FileSpec::default</span>())         <span class="comment">// write logs to file</span>
    .<span class="ident">duplicate_to_stderr</span>(<span class="ident">Duplicate::Warn</span>)     <span class="comment">// print warnings and errors also to the console</span>
    .<span class="ident">start</span>()<span class="question-mark">?</span>;</code></pre></div>
<h3 id="choose-the-write-mode"><a href="#choose-the-write-mode">Choose the write mode</a></h3>
<p>By default, every log line is directly written to the output, without buffering.
This allows seeing new log lines in real time.</p>
<p>With <a href="../struct.Logger.html#method.write_mode"><code>Logger::write_mode</code></a>
you have some options to change this behavior, e.g.</p>
<ul>
<li>
<p>with <a href="../enum.WriteMode.html#variant.BufferAndFlush"><code>WriteMode::BufferAndFlush</code></a>,
or <a href="../enum.WriteMode.html#variant.BufferAndFlushWith"><code>WriteMode::BufferAndFlushWith</code></a>,
you can reduce the program’s I/O overhead and thus increase overall performance,
which can be relevant if logging is used heavily.
In addition, to keep a short maximum wait time
until a log line is visible in the output channel,
an extra thread is created that flushes the buffers regularly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">std::error::Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">_logger</span> <span class="op">=</span> <span class="ident">Logger::try_with_str</span>(<span class="string">&quot;info&quot;</span>)<span class="question-mark">?</span>
       .<span class="ident">log_to_file</span>(<span class="ident">FileSpec::default</span>())
       .<span class="ident">write_mode</span>(<span class="ident">WriteMode::BufferAndFlush</span>)
       .<span class="ident">start</span>()<span class="question-mark">?</span>;
    <span class="comment">// ... do all your work ...</span>
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</li>
<li>
<p>with <a href="crate::WriteMode::Async"><code>WriteMode::Async</code></a>
or <a href="crate::WriteMode::AsyncWith"><code>WriteMode::AsyncWith</code></a>,
logs are sent from your application threads through an unbounded channel
to an output thread, which does the output (and the rotation and the cleanup, if applicable).
Additionally the output is buffered, and a bounded message pool is used to reduce allocations,
and flushing is used to avoid long delays.
If duplication is used, the messages to <code>stdout</code> or <code>stderr</code> are written synchronously.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">std::error::Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">_logger</span> <span class="op">=</span> <span class="ident">Logger::try_with_str</span>(<span class="string">&quot;info&quot;</span>)<span class="question-mark">?</span>
       .<span class="ident">log_to_file</span>(<span class="ident">FileSpec::default</span>())
       .<span class="ident">write_mode</span>(<span class="ident">WriteMode::Async</span>)
       .<span class="ident">start</span>()<span class="question-mark">?</span>;
    <span class="comment">// ... do all your work ...</span>
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</li>
</ul>
<p><strong>Note</strong> that with all write modes
except <a href="../enum.WriteMode.html#variant.Direct"><code>WriteMode::Direct</code></a> (which is the default)
you should keep the <a href="../struct.LoggerHandle.html"><code>LoggerHandle</code></a> alive
up to the very end of your program,
because it will, in its Drop implementation, flush all writers
to ensure that all buffered log lines are flushed before the program terminates,
and then it calls their shutdown method.</p>
<h3 id="influence-the-location-and-name-of-the-log-file"><a href="#influence-the-location-and-name-of-the-log-file">Influence the location and name of the log file</a></h3>
<p>By default, the log files are created in the current directory (where the program was started).
With <a href="../struct.FileSpec.html#method.directory"><code>FileSpec:directory</code></a>
you can specify a concrete folder in which the files should be created.</p>
<p>Using <a href="../struct.FileSpec.html#method.discriminant"><code>FileSpec::discriminant</code></a>
you can add a discriminating infix to the log file name.</p>
<p>With <a href="../struct.FileSpec.html#method.suffix"><code>FileSpec::suffix</code></a>
you can change the suffix that is used for the log files.</p>
<p>When writing to files, especially when they are in a distant folder, you may want to let the
user know where the log file is.</p>
<p><a href="../struct.Logger.html#method.print_message"><code>Logger::print_message</code></a>
prints an info to <code>stdout</code> to which file the log is written.</p>
<p><a href="../struct.Logger.html#method.create_symlink"><code>Logger::create_symlink</code></a>
creates (on unix-systems only) a symbolic link at the specified path that points to the log file.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">Logger::try_with_str</span>(<span class="string">&quot;info&quot;</span>)<span class="question-mark">?</span>
    .<span class="ident">log_to_file</span>(
        <span class="ident">FileSpec::default</span>()
            .<span class="ident">directory</span>(<span class="string">&quot;log_files&quot;</span>)          <span class="comment">// create files in folder ./log_files</span>
            .<span class="ident">basename</span>(<span class="string">&quot;foo&quot;</span>)
            .<span class="ident">discriminant</span>(<span class="string">&quot;Sample4711A&quot;</span>)     <span class="comment">// use infix in log file name</span>
            .<span class="ident">suffix</span>(<span class="string">&quot;trc&quot;</span>)                   <span class="comment">// use suffix .trc instead of .log</span>
    )
    .<span class="ident">print_message</span>()                         <span class="comment">//</span>
    .<span class="ident">create_symlink</span>(<span class="string">&quot;current_run&quot;</span>)           <span class="comment">// create a symbolic link to the current log file</span>
    .<span class="ident">start</span>()<span class="question-mark">?</span>;</code></pre></div>
<p>This example will print a message like
“Log is written to <code>./log_files/foo_Sample4711A_2020-11-17_19-24-35.trc</code>”
and, on unix, create a symbolic link called <code>current_run</code>.</p>
<h3 id="specify-the-format-for-the-log-lines-explicitly"><a href="#specify-the-format-for-the-log-lines-explicitly">Specify the format for the log lines explicitly</a></h3>
<p>With <a href="../struct.Logger.html#method.format"><code>Logger::format</code></a>
you set the format for all used output channels of <code>flexi_logger</code>.</p>
<p><code>flexi_logger</code> provides a couple of format functions, and you can also create and use your own,
e.g. by copying and modifying one of the provided format functions.</p>
<p>Depending on the configuration, <code>flexi_logger</code> can write logs to multiple channels
(stdout, stderr, files, or additional writers)
at the same time. You can control the format for each output channel individually, using
<a href="../struct.Logger.html#method.format_for_files"><code>Logger::format_for_files</code></a>,
<a href="../struct.Logger.html#method.format_for_stderr"><code>Logger::format_for_stderr</code></a>,
<a href="../struct.Logger.html#method.format_for_stdout"><code>Logger::format_for_stdout</code></a>, or
<a href="../struct.Logger.html#method.format_for_writer"><code>Logger::format_for_writer</code></a>.</p>
<p>As argument for these functions you can use one of the provided non-coloring format functions</p>
<ul>
<li><a href="../fn.default_format.html"><code>default_format</code></a></li>
<li><a href="../fn.detailed_format.html"><code>detailed_format</code></a></li>
<li><a href="../fn.opt_format.html"><code>opt_format</code></a></li>
<li><a href="../fn.with_thread.html"><code>with_thread</code></a>,</li>
</ul>
<p>or one of their coloring pendants</p>
<ul>
<li><a href="../fn.colored_default_format.html"><code>colored_default_format</code></a></li>
<li><a href="../fn.colored_detailed_format.html"><code>colored_detailed_format</code></a></li>
<li><a href="../fn.colored_opt_format.html"><code>colored_opt_format</code></a></li>
<li><a href="../fn.colored_with_thread.html"><code>colored_with_thread</code></a>,</li>
</ul>
<p>or your own method.</p>
<h4 id="adaptive-coloring"><a href="#adaptive-coloring">Adaptive Coloring</a></h4>
<p>You can use coloring for <code>stdout</code> and/or <code>stderr</code>
<em>conditionally</em>, such that colors</p>
<ul>
<li>are used when the output goes to a tty,</li>
<li>are suppressed when you e.g. pipe the output to some other program.</li>
</ul>
<p>You achieve that
by providing one of the variants of <a href="../enum.AdaptiveFormat.html"><code>AdaptiveFormat</code></a> to the respective
format method, e.g.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>      <span class="ident">flexi_logger::Logger::try_with_str</span>(<span class="string">&quot;info&quot;</span>)<span class="question-mark">?</span>
          .<span class="ident">adaptive_format_for_stderr</span>(<span class="ident">AdaptiveFormat::Detailed</span>);</code></pre></div>
<h4 id="defaults"><a href="#defaults">Defaults</a></h4>
<p><code>flexi_logger</code> initializes by default equivalently to this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>      <span class="comment">// ...</span>
      .<span class="ident">adaptive_format_for_stderr</span>(<span class="ident">AdaptiveFormat::Default</span>)
      .<span class="ident">adaptive_format_for_stdout</span>(<span class="ident">AdaptiveFormat::Default</span>)
      .<span class="ident">format_for_files</span>(<span class="ident">default_format</span>)
      .<span class="ident">format_for_writer</span>(<span class="ident">default_format</span>)</code></pre></div>
<h3 id="use-a-fixed-log-file-and-truncate-or-append-the-file-on-each-program-start"><a href="#use-a-fixed-log-file-and-truncate-or-append-the-file-on-each-program-start">Use a fixed log file, and truncate or append the file on each program start</a></h3>
<p>With <a href="../struct.Logger.html#method.log_to_file"><code>Logger::log_to_file</code></a> and without rotation,
<code>flexi_logger</code> uses by default files with a timestamp in the name, like
<code>foo_2020-11-16_08-37-44.log</code> (for a program called <code>foo</code>), which are quite unique for each
program start.</p>
<p>With <a href="../struct.FileSpec.html#method.suppress_timestamp"><code>FileSpec::suppress_timestamp</code></a>
you get a simple fixed filename, like <code>foo.log</code>.</p>
<p>In that case, a restart of the program will truncate an existing log file.</p>
<p>Use additionally <a href="../struct.Logger.html#method.append"><code>Logger::append</code></a>
to append the logs of each new run to the existing file.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">Logger::try_with_str</span>(<span class="string">&quot;info&quot;</span>)<span class="question-mark">?</span> <span class="comment">// Write all error, warn, and info messages</span>
    <span class="comment">// use a simple filename without a timestamp</span>
    .<span class="ident">log_to_file</span>(
        <span class="ident">FileSpec::default</span>().<span class="ident">suppress_timestamp</span>()
    )
    <span class="comment">// do not truncate the log file when the program is restarted</span>
    .<span class="ident">append</span>()
    .<span class="ident">start</span>()<span class="question-mark">?</span>;
</code></pre></div>
<h3 id="rotate-the-log-file"><a href="#rotate-the-log-file">Rotate the log file</a></h3>
<p>With rotation, the logs are always written to a file
with the infix <code>rCURRENT</code>, like e.g. <code>foo_rCURRENT.log</code>.</p>
<p><a href="../struct.Logger.html#method.rotate"><code>Logger::rotate</code></a>
takes three enum arguments that define its behavior:</p>
<ul>
<li>
<p><a href="../enum.Criterion.html"><code>Criterion</code></a></p>
<ul>
<li>with <a href="../enum.Criterion.html#variant.Age"><code>Criterion::Age</code></a> the rotation happens
when the clock switches to a new day, hour, minute, or second</li>
<li>with <a href="../enum.Criterion.html#variant.Size"><code>Criterion::Size</code></a> the rotation happens
when the current log file exceeds the specified limit</li>
<li>with <a href="../enum.Criterion.html#variant.AgeOrSize"><code>Criterion::AgeOrSize</code></a> the rotation happens
when either of the two limits is reached</li>
</ul>
</li>
<li>
<p><a href="../enum.Naming.html"><code>Naming</code></a><br>The current file is then renamed</p>
<ul>
<li>with <a href="../enum.Naming.html#variant.Timestamps"><code>Naming::Timestamps</code></a> to something
like <code>foo_r2020-11-16_08-56-52.log</code></li>
<li>with <a href="../enum.Naming.html#variant.Numbers"><code>Naming::Numbers</code></a> to something like <code>foo_r00000.log</code></li>
</ul>
<p>and a fresh <code>rCURRENT</code> file is created.</p>
</li>
<li>
<p><a href="../enum.Cleanup.html"><code>Cleanup</code></a> defines if and how you
avoid accumulating log files indefinitely:</p>
<ul>
<li>with <a href="../enum.Cleanup.html#variant.KeepLogFiles"><code>Cleanup::KeepLogFiles</code></a> you specify
the number of log files that should be retained;
if there are more, the older ones are getting deleted</li>
<li>with <a href="crate::Cleanup::KeepCompressedFiles"><code>Cleanup::KeepCompressedFiles</code></a> you specify
the number of log files that should be
retained, and these are being compressed additionally</li>
<li>with <a href="crate::Cleanup::KeepLogAndCompressedFiles"><code>Cleanup::KeepLogAndCompressedFiles</code></a>
you specify the number of log files that should be
retained as is, and an additional number that are being compressed</li>
<li>with <a href="../enum.Cleanup.html#variant.Never"><code>Cleanup::Never</code></a> no cleanup is done, all files are retained.</li>
</ul>
</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">Logger::try_with_str</span>(<span class="string">&quot;info&quot;</span>)<span class="question-mark">?</span>      <span class="comment">// Write all error, warn, and info messages</span>
    .<span class="ident">log_to_file</span>(
        <span class="ident">FileSpec::default</span>()
    )
    .<span class="ident">rotate</span>(                      <span class="comment">// If the program runs long enough,</span>
        <span class="ident">Criterion::Age</span>(<span class="ident">Age::Day</span>), <span class="comment">// - create a new file every day</span>
        <span class="ident">Naming::Timestamps</span>,       <span class="comment">// - let the rotated files have a timestamp in their name</span>
        <span class="ident">Cleanup::KeepLogFiles</span>(<span class="number">7</span>), <span class="comment">// - keep at most 7 log files</span>
    )
    .<span class="ident">start</span>()<span class="question-mark">?</span>;
</code></pre></div>
<h3 id="reconfigure-the-log-specification-programmatically"><a href="#reconfigure-the-log-specification-programmatically">Reconfigure the log specification programmatically</a></h3>
<p>This can be especially handy in debugging situations where you want to see
log output only for a short instant.</p>
<p>Obtain the <a href="../struct.LoggerHandle.html"><code>LoggerHandle</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">logger</span> <span class="op">=</span> <span class="ident">Logger::try_with_str</span>(<span class="string">&quot;info&quot;</span>).<span class="ident">unwrap</span>()
    <span class="comment">// ... logger configuration ...</span>
    .<span class="ident">start</span>()
    .<span class="ident">unwrap</span>();</code></pre></div>
<p>and modify the effective log specification from within your code:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="comment">// ...</span>
<span class="ident">logger</span>.<span class="ident">parse_and_push_temp_spec</span>(<span class="string">&quot;info, critical_mod = trace&quot;</span>);
<span class="comment">// ... critical calls ...</span>
<span class="ident">logger</span>.<span class="ident">pop_temp_spec</span>();
<span class="comment">// ... continue with the log spec you had before.</span></code></pre></div>
<h3 id="reconfigure-the-log-specification-dynamically-by-editing-a-spec-file"><a href="#reconfigure-the-log-specification-dynamically-by-editing-a-spec-file">Reconfigure the log specification dynamically by editing a spec-file</a></h3>
<p>If you start <code>flexi_logger</code> with a specfile,</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">Logger::try_with_str</span>(<span class="string">&quot;info&quot;</span>).<span class="ident">unwrap</span>()
    <span class="comment">// ... logger configuration ...</span>
   .<span class="ident">start_with_specfile</span>(<span class="string">&quot;./server/config/logspec.toml&quot;</span>)
   .<span class="ident">unwrap</span>();</code></pre></div>
<p>then you can change the log specification dynamically, <em>while your program is running</em>,
by editing the specfile. This can be a great help e.g. if you want to get detailed log output
for <em>some</em> requests to a long running server.</p>
<p>See <a href="crate::Logger::start_with_specfile"><code>Logger::start_with_specfile</code></a>
for more information.</p>
<h3 id="reconfigure-the-file-log-writer"><a href="#reconfigure-the-file-log-writer">Reconfigure the file log writer</a></h3>
<p>When using <code>Logger::log_to_file()</code>, you can change most of the properties of the
embedded <code>FileLogWriter</code> while the program is running using
<a href="../struct.LoggerHandle.html#method.reset_flw"><code>Logger::reset_flw</code></a>.</p>
<p>Obtain the <a href="../struct.LoggerHandle.html"><code>LoggerHandle</code></a> when the program is started</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">flexi_logger</span>::{<span class="ident">writers::FileLogWriter</span>, <span class="ident">Cleanup</span>, <span class="ident">Criterion</span>, <span class="ident">FileSpec</span>, <span class="ident">Naming</span>};

<span class="kw">let</span> <span class="ident">logger</span> <span class="op">=</span> <span class="ident">flexi_logger::Logger::try_with_str</span>(<span class="string">&quot;info&quot;</span>)<span class="question-mark">?</span>
    .<span class="ident">log_to_file</span>(
        <span class="ident">FileSpec::default</span>()
            .<span class="ident">basename</span>(<span class="string">&quot;phase1&quot;</span>)
            .<span class="ident">directory</span>(<span class="string">&quot;./log_files&quot;</span>)
    )
    .<span class="ident">start</span>()<span class="question-mark">?</span>;

<span class="macro">log::info!</span>(<span class="string">&quot;start of phase 1&quot;</span>);</code></pre></div>
<p>and modify the file log writer later:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">logger</span>.<span class="ident">reset_flw</span>(
    <span class="kw-2">&amp;</span><span class="ident">FileLogWriter::builder</span>(
        <span class="ident">FileSpec::default</span>()
            .<span class="ident">basename</span>(<span class="string">&quot;phase2&quot;</span>)
            .<span class="ident">directory</span>(<span class="string">&quot;./log_files&quot;</span>)
    )
    .<span class="ident">append</span>()
    .<span class="ident">rotate</span>(
        <span class="ident">Criterion::Size</span>(<span class="number">1024</span> <span class="op">*</span> <span class="number">1000</span> <span class="op">*</span> <span class="number">1</span>),
        <span class="ident">Naming::Numbers</span>,
        <span class="ident">Cleanup::KeepLogFiles</span>(<span class="number">3</span>),
    ),
)<span class="question-mark">?</span>;

<span class="macro">log::info!</span>(<span class="string">&quot;start of phase 2&quot;</span>);</code></pre></div>
<h3 id="external-file-rotators"><a href="#external-file-rotators">External file rotators</a></h3>
<p>If the log is written to files, <code>flexi_logger</code> decides, based on your configuration,
to which file(s) the log is written, and expects that nobody else modifies these files.
It offers quite some functionality to rotate, compress, and clean up log files.</p>
<p>Alternatively, tools like linux’ <code>logrotate</code> can be used to rotate, compress or remove
log files. But renaming or deleting the current output file e.g. might not stop
<code>flexi_logger</code> from writing to the now renamed file!
See <a href="../struct.LoggerHandle.html#method.reopen_outputfile"><code>LoggerHandle::reopen_outputfile</code></a>
to understand how to cope with external rotators.</p>
<h3 id="miscellaneous"><a href="#miscellaneous">Miscellaneous</a></h3>
<p>For the sake of completeness, we refer here to some more configuration methods.
See their documentation for more details.</p>
<p><a href="../struct.Logger.html#method.set_palette"><code>Logger::set_palette</code></a></p>
<p><a href="../struct.Logger.html#method.cleanup_in_background_thread"><code>Logger::cleanup_in_background_thread</code></a></p>
<p><a href="../struct.Logger.html#method.use_windows_line_ending"><code>Logger::use_windows_line_ending</code></a></p>
<p><a href="../struct.Logger.html#method.add_writer"><code>Logger::add_writer</code></a></p>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="flexi_logger" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.64.0-nightly (9067d5277 2022-07-28)" ></div>
</body></html>